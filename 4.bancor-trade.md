# bancorå»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€è§£æï¼ˆ4ï¼‰äº¤æ˜“åŠåˆçº¦åˆ†æ

## ä»‹ç»

æ¥ä¸‹æ¥ä»‹ç»bancoræœ€æ ¸å¿ƒçš„éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯å¦‚ä½•è¿›è¡Œäº¤æ˜“ï¼Œå› ä¸ºç¯‡å¹…å¾ˆå¤šï¼Œè¿™é‡Œå°±åªä»‹ç»æ ¸å¿ƒéƒ¨åˆ†

### åœ¨åˆçº¦ä¸Šçš„æµç¨‹å›¾

è¿™å¼ æµç¨‹å›¾æ˜¯ä¸€æ¬¡äº¤æ˜“åˆçº¦è°ƒç”¨æ–¹æ³•çš„æµç¨‹ï¼Œå‰é¢çš„åˆçº¦åï¼Œåé¢æ˜¯åˆçº¦æ–¹æ³•ã€‚

æ³¨æ„è¿™æ˜¯å†…éƒ¨è°ƒç”¨çš„æµç¨‹ï¼Œä¹Ÿå°±æ˜¯å‡å®šæ‰€æœ‰çš„å¸éƒ½å·²ç»åœ¨bancorç½‘ç»œä¸Šæ³¨å†Œè¿‡äº†ï¼Œbancoråˆçº¦æ¯”è¾ƒå¤æ‚ï¼Œæ”¯æŒè‡ªå·±çš„é’±åŒ…å‘èµ·çš„äº¤æ˜“ï¼Œä¹Ÿæ”¯æŒç¬¬ä¸‰æ–¹é’±åŒ…é’±åŒ…å‘èµ·çš„äº¤æ˜“ï¼Œæ ¹æ®ä¼˜å…ˆçº§ä¸åŒï¼Œä¼šæ”¶å–ä¸åŒçš„æ‰‹ç»­è´¹

![image.png](https://upload-images.jianshu.io/upload_images/13856335-d938132984e2b55a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


ç”±äºä»£ç å¾ˆå¤šï¼Œè¿™é‡Œå°±åªæŒ‘å‡ å¤„é‡è¦çš„ä»£ç è¿›è¡Œè§£æï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥è·Ÿç€è¿™ä¸ªæµç¨‹å›¾å»åˆçº¦é‡Œæ…¢æ…¢ç ”ç©¶

### å…¥å£

```solidity
    @dev converts the token to any other token in the bancor network by following
        a predefined conversion path and transfers the result tokens back to the sender
        note that the converter should already own the source tokens

        @param _path        conversion path, see conversion path format above
        @param _amount      amount to convert from (in the initial source token)
        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero

        @return tokens issued in return
    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {
        return convertFor(_path, _amount, _minReturn, msg.sender);
    }

```
å½“è§£æå¥½è½¬åŒ–è·¯å¾„åï¼Œå°±ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œè¿™é‡Œåšçš„äº‹å¾ˆç®€å•ï¼Œå°±åªæ˜¯å§msg.senderå½“åšå‚æ•°ä¼ ä¸‹å»


### å…‘æ¢

```solidity

/**
        @dev executes the actual conversion by following the conversion path

        @param _path        conversion path, see conversion path format above
        @param _amount      amount to convert from (in the initial source token)
        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero
        @param _fromToken   ERC20 token to convert from (the first element in the path)
        @param _for         account that will receive the conversion result

        @return ERC20 token to convert to (the last element in the path) & tokens issued in return
    */
    function convertByPath(
        IERC20Token[] _path,
        uint256 _amount,
        uint256 _minReturn,
        IERC20Token _fromToken,
        address _for
    ) private returns (IERC20Token, uint256) {
        ISmartToken smartToken;
        IERC20Token toToken;
        IBancorConverter converter;

        // get the contract features address from the registry
        IContractFeatures features = IContractFeatures(registry.addressOf(ContractIds.CONTRACT_FEATURES));

        // æ ¹æ®è·¯å¾„å¤šæ¬¡è½¬æ¢ï¼Œæœ€ç»ˆæ¢æˆç›®æ ‡ä»£å¸
        uint256 pathLength = _path.length;
        for (uint256 i = 1; i < pathLength; i += 2) {
            smartToken = ISmartToken(_path[i]);
            toToken = _path[i + 1];
            converter = IBancorConverter(smartToken.owner());
            checkWhitelist(converter, _for, features);

            // if the smart token isn't the source (from token), the converter doesn't have control over it and thus we need to approve the request
            if (smartToken != _fromToken)
                ensureAllowance(_fromToken, converter, _amount);

            // è¿™é‡Œæ˜¯çœŸæ­£æ‰§è¡Œè½¬æ¢çš„æ–¹æ³•
            _amount = converter.change(_fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);
            _fromToken = toToken;
        }
        return (toToken, _amount);
    }

```

`ContractFeatures`é‡Œé¢å­˜äº†å¦‚ä½•è®¡ç®—ä»·æ ¼éœ€è¦çš„å†…å®¹ï¼ŒçœŸæ­£çš„Bancorç®—æ³•çš„åˆçº¦åæ˜¯`BancorFormula`ã€‚

åœ¨è¿™ä¸ªæ–¹æ³•é‡Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªå¾ªç¯ï¼Œéå¸¸çš„å¥‡æ€ªï¼Œæ¯æ¬¡å¾ªç¯éƒ½æ˜¯åŠ 2ã€‚

è¿™æ ·åšçš„åŸå› æ˜¯æˆ‘ä»¬è¿›è¡Œè´§å¸å…‘æ¢çš„æ—¶å€™ï¼Œæˆ‘ä»¬çš„æºè´§å¸è·Ÿç›®æ ‡è´§å¸ï¼Œå¹¶ä¸ä¸€å®šæ˜¯ç»è¿‡ä¸€æ¬¡è½¬åŒ–å°±å¯ä»¥å®Œæˆï¼Œå› ä¸ºæˆ‘ä»¬æ‰€æœ‰ä»£å¸çš„ä¸­è½´æ˜¯BNTï¼Œåªè¦ä¸¤ä¸ªéBNTçš„ä»£å¸å…‘æ¢å°±ä¼šèµ·ç éœ€è¦ä¸¤æ¬¡ã€‚

ä¸¾ä¸ªğŸŒ°

å‡å¦‚æˆ‘æœ‰ä¸¤ä¸ªä»£å¸ï¼ŒERAå’ŒERBï¼Œé‚£ä¹ˆä¼ è¿›æ¥çš„pathä¼šæ˜¯

```
[ERA, ERABNT, BNT, ERBBNT, ERB]
```

è¿™é‡Œåªæ˜¯ä¼ªä»£ç ï¼Œæ•°ç»„ç±»å‹å®é™…æ˜¯IERC20ç±»å‹çš„ã€‚

é‚£ä¹ˆä¸ºä»€ä¹ˆè¦+2å‘¢ï¼Œå‰é¢æˆ‘ä»¬è¯´è¿‡äº†ï¼Œ`BancorConverter`æ˜¯åŸºäºæŸä¸€ä¸ªæ™ºèƒ½ä»£å¸çš„ï¼Œå¯ä»¥ç›´æ¥å…‘æ¢ä¸¤ä¸ªä»£å¸çš„å€¼ï¼Œæ‰€ä»¥ï¼Œå…‘æ¢ä¸€æ¬¡ï¼Œéœ€è¦3ä¸ªæ•°[fromToken, smartToken, toToken]ã€‚

### å¢åŠ å‡å°‘é’±åŒ…çš„å€¼

```solidity

 /**
        @dev converts a specific amount of _fromToken to _toToken

        @param _fromToken  ERC20 token to convert from
        @param _toToken    ERC20 token to convert to
        @param _amount     amount to convert, in fromToken
        @param _minReturn  if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero

        @return conversion return amount
    */
    function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn)
        public
        bancorNetworkOnly
        conversionsAllowed
        greaterThanZero(_minReturn)
        returns (uint256)
    {
        require(_fromToken != _toToken); // validate input

        // conversion between the token and one of its connectors
        if (_toToken == token)
            return buy(_fromToken, _amount, _minReturn);
        else if (_fromToken == token)
            return sell(_toToken, _amount, _minReturn);

        // conversion between 2 connectors
        uint256 amount = getCrossConnectorReturn(_fromToken, _toToken, _amount);
        // ensure the trade gives something in return and meets the minimum requested amount
        require(amount != 0 && amount >= _minReturn);

        // æ›´æ–°æºtokenè¿æ¥å™¨å‚¨å¤‡é‡
        Connector storage fromConnector = connectors[_fromToken];
        if (fromConnector.isVirtualBalanceEnabled)
            fromConnector.virtualBalance = safeAdd(fromConnector.virtualBalance, _amount);

        // æ›´æ–°ç›®æ ‡tokenè¿æ¥å™¨å‚¨å¤‡é‡
        Connector storage toConnector = connectors[_toToken];
        if (toConnector.isVirtualBalanceEnabled)
            toConnector.virtualBalance = safeSub(toConnector.virtualBalance, amount);

        // ensure that the trade won't deplete the connector balance
        uint256 toConnectorBalance = getConnectorBalance(_toToken);
        assert(amount < toConnectorBalance);

        // æºtokenç›®æ ‡ä½™é¢å‡å°‘
        assert(_fromToken.transferFrom(msg.sender, this, _amount));
        // ç›®æ ‡tokené’±åŒ…ä½™é¢å¢åŠ 
        assert(_toToken.transfer(msg.sender, amount));

        // calculate conversion fee and dispatch the conversion event
        // the fee is higher (magnitude = 2) since cross connector conversion equals 2 conversions (from / to the smart token)
        uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 2));
        dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount);

        // dispatch price data updates for the smart token / both connectors
        emit PriceDataUpdate(_fromToken, token.totalSupply(), getConnectorBalance(_fromToken), fromConnector.weight);
        emit PriceDataUpdate(_toToken, token.totalSupply(), getConnectorBalance(_toToken), toConnector.weight);
        return amount;
    }

```


## æ€»ç»“

åˆ°è¿™é‡Œï¼Œbancorå»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€çš„åˆ†æå°±å‘Šä¸€æ®µè½äº†ï¼Œè¿™ä¸ªç³»åˆ—åªæ˜¯ç²—çº¿çš„ä»‹ç»äº†ä¸€ä¸‹è¿™ä¸ªå»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€çš„æ ¸å¿ƒæµç¨‹ï¼Œå®é™…ä¸Šè¿™ä¸ªäº¤æ˜“æ‰€çš„åˆçº¦éå¸¸å¤šï¼Œè€Œä¸”ååˆ†å¤æ‚ï¼Œé‡Œé¢ä½¿ç”¨äº†å¾ˆå¤šsolidityçš„æŠ€å·§ï¼Œå¦‚æœæ„Ÿå…´è¶£çš„åŒå­¦ï¼Œå¯ä»¥å»çœ‹çœ‹[ä¼ é€é—¨](https://github.com/bancorprotocol)ã€‚